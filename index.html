<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>wikipoetry kilian</title>
<style>
body {
  font-family: "Helvetica", sans-serif;
  max-width: 800px;
  margin: 2em auto;
  background-image: url("infinity.jpg"); /* ðŸ”¹ ton image ici */
  background-size: cover;                 /* couvre tout lâ€™Ã©cran */
  background-position: center;            /* centrÃ©e */
  background-repeat: no-repeat;           /* pas de rÃ©pÃ©tition */
  background-attachment: fixed;           /* effet de fond fixe */
  color: #222;
  padding: 1em;
  backdrop-filter: brightness(0.9);       /* optionnel pour lisibilitÃ© */
}

/* Pour un effet lisible sur fond clair ou sombre */
body::before {
  content: "";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: rgba(255,255,255,0.6); /* voile blanc transparent */
  z-index: -1;
}

button {
  font-family: "Helvetica", sans-serif;
  font-size: 1.2em;
  padding: 12px 24px;
  margin: 1em auto;
  display: block;
  cursor: pointer;
  border: none;
  background: rgba(255, 255, 255, 0.7);
  border-radius: 8px;
}

#poem {
  white-space: pre-line;
  margin-top: 2em;
  font-size: 1.1em;
  padding-top: 1em;
  min-height: 10em;
  color: #fff; /* ðŸ”¹ blanc pour bien ressortir sur lâ€™image */
  border: none; /* ðŸ”¹ plus de trait */
  background: none; /* ðŸ”¹ plus de fond gris */
}
</style>
</head>
<body>

<h1>4 kilian</h1>
<button id="generate" onclick="generatePoem()">crÃ©er un poÃ¨me</button>
<div id="poem">cliquez sur le bouton pour gÃ©nÃ©rer un poÃ¨me...</div>

<script>
// mÃªme JavaScript que le tien (inchangÃ©)
const wikiPages = [
  { lang: 'fr', title: 'FÃªte foraine' },
  { lang: 'en', title: 'Traveling carnival' }
];
const poeticWords = ['doucement','lÃ -bas','comme un rÃªve','en silence','Ã©toile','brume','suspirant','Ã  lâ€™horizon','tel un Ã©cho','dans la lumiÃ¨re'];

async function fetchWikiContent(lang, title) {
  const url = `https://${lang}.wikipedia.org/w/api.php?action=query&origin=*&prop=extracts&explaintext&format=json&titles=${title}`;
  const response = await fetch(url);
  const data = await response.json();
  const pages = data.query.pages;
  const page = Object.values(pages)[0];
  return page.extract;
}

function textToFragments(text) {
  let sentences = text.split(/[.!?]/).map(s => s.trim()).filter(s => s.length > 0);
  let fragments = [];
  sentences.forEach(sentence => {
    let parts = sentence.split(/[,;:]/).map(p => p.trim()).filter(p => p.length > 0);
    parts.forEach(part => {
      let words = part.split(' ').filter(w => w.length > 0);
      for (let i = 0; i < words.length; i += 2) {
        let fragLength = Math.min(Math.floor(Math.random() * 11) + 2, words.length - i);
        let fragment = words.slice(i, i + fragLength).join(' ');
        fragments.push(fragment);
      }
    });
  });
  return fragments;
}

function shuffleWords(fragment) {
  let words = fragment.split(' ');
  for (let i = words.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [words[i], words[j]] = [words[j], words[i]];
  }
  return words.join(' ');
}

function approximateRhyme(word, fragments) {
  const lastChar = word.slice(-2);
  const rhymes = fragments.filter(f => f.slice(-2) === lastChar && f !== word);
  if (rhymes.length > 0) return rhymes[Math.floor(Math.random() * rhymes.length)];
  return null;
}

function filterProperNouns(fragments) {
  return fragments.filter(fragment => {
    const words = fragment.split(' ').filter(w => w.length > 0);
    let capitalCount = 0;
    words.forEach((w, i) => {
      if (w[0] === w[0].toUpperCase() && w.match(/[A-ZÃ€-Å¸]/) && i !== 0) capitalCount++;
    });
    return (capitalCount / words.length) < 0.5;
  });
}

async function generatePoem() {
  let allFragments = [];
  for (let page of wikiPages) {
    try {
      const content = await fetchWikiContent(page.lang, page.title);
      let fragments = textToFragments(content);
      allFragments.push(...fragments);
    } catch(e) {
      console.error("Erreur en rÃ©cupÃ©rant la page :", page.title, e);
    }
  }
  allFragments = filterProperNouns(allFragments);
  let poem = '';
  let lineCount = Math.floor(Math.random() * 5) + 6;

  for (let i = 0; i < lineCount; i++) {
    if (allFragments.length === 0) break;
    let idx = Math.floor(Math.random() * allFragments.length);
    let fragment = allFragments[idx];
    if (Math.random() > 0.5) fragment = shuffleWords(fragment);
    if (Math.random() > 0.6) {
      if (Math.random() > 0.5) fragment = `${poeticWords[Math.floor(Math.random() * poeticWords.length)]}, ${fragment}`;
      else fragment = `${fragment}, ${poeticWords[Math.floor(Math.random() * poeticWords.length)]}`;
    }
    if (i > 0) {
      const lastLine = poem.split('\n').filter(l => l.length > 0).slice(-1)[0];
      const lastWord = lastLine.split(' ').slice(-1)[0];
      const rhyme = approximateRhyme(lastWord, allFragments);
      if (rhyme && Math.random() > 0.5) fragment += ', ' + rhyme;
    }
    poem += fragment + '\n';
  }

  document.getElementById('poem').textContent = poem;
}
</script>

</body>
</html>
